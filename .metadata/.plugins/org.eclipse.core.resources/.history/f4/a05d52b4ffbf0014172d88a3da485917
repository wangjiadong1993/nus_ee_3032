//*****************************************************************************
// LPC1769_CMSIS_MCU_blinky
// ==========
// CK Tham, ECE, NUS
// June 2011
// adapted from Code Red LPCXpresso1768_systick
// to use Lib_MCU : PINSEL and GPIO
// see readme.txt file
//*****************************************************************************

// CMSIS headers required for setting up SysTick Timer
#include "LPC17xx.h"

// Lib_MCU header files
#include "lpc17xx_pinsel.h"
#include "lpc17xx_gpio.h"
#include "lpc17xx_uart.h"
#include "string.h"
#include "stdio.h"


volatile uint32_t msTicks; // counter for 1ms SysTicks
char str[1024] = "0";
int num = 0;
char time[20] = "0";
char lon[20] = "0";
char lat[20] = "0";
char dat[20] = "0";
// ****************
//  SysTick_Handler - just increment SysTick counter
void SysTick_Handler(void) {
  msTicks++;
}

// ****************
// systick_delay - creates a delay of the appropriate number of Systicks (happens every 1 ms)
__INLINE static void systick_delay (uint32_t delayTicks) {
  uint32_t currentTicks;

  currentTicks = msTicks;	// read current tick counter
  // Now loop until required number of ticks passes
  while ((msTicks - currentTicks) < delayTicks);
}

void initial_gpio()
{
	PINSEL_CFG_Type PinCfg;
	PinCfg.Funcnum = 0;
	PinCfg.Pinnum = 9;
	PinCfg.Portnum = 0; //P0.0 fun2 is TXD3
	PINSEL_ConfigPin(&PinCfg);
	GPIO_SetDir(0, 1<<9, 1);
	GPIO_SetValue(0, 1<<9);
//	PinCfg.Pinnum = 0; //P0.1 fun2 is RXD3
//	PINSEL_ConfigPin(&PinCfg);
	//UART2
	//LPC_UART3
}

void pinsel_uart2(void)
{
	PINSEL_CFG_Type PinCfg;
	PinCfg.Funcnum = 1;
	PinCfg.Pinnum = 10;
	PinCfg.Portnum = 0; //P0.10 fun2 is TXD2
	PINSEL_ConfigPin(&PinCfg);
	PinCfg.Pinnum = 11; //P0.11 fun2 is RXD2
	PINSEL_ConfigPin(&PinCfg);
}

void init_uart(void)
{
	UART_CFG_Type uartCfg;
	uartCfg.Baud_rate = 9600;  			 	//baud rate 9600
	uartCfg.Databits = UART_DATABIT_8;		//8bits signal
	uartCfg.Parity = UART_PARITY_NONE;		//none parity bit
	uartCfg.Stopbits = UART_STOPBIT_1;		//1 stop bit
	pinsel_uart2(); 						//pin select for uart3
	UART_Init(LPC_UART2, &uartCfg);			//supply power & setup working par.s for uart3
	UART_TxCmd(LPC_UART2,ENABLE);			//enable transmit for uart3
	LPC_UART2->FCR = (UART_FCR_FIFO_EN|UART_FCR_RX_RS|UART_FCR_TX_RS|UART_FCR_TRG_LEV0);//enable FIFO
	UART_IntConfig(LPC_UART2, UART_INTCFG_RBR, ENABLE); //enable RBR
}

// Function to initialise GPIO to access LED2

void UART2_IRQHandler(void)
{
	//printf("interrupted\n");
	uint8_t roo = 100;
	char* substr =NULL;
	char* s = NULL;
	int i =0;
	int j=0;
	UART_Receive(LPC_UART2,&roo,1, BLOCKING);
	str[num]=roo;
	num++;
	//printf("in interrupt\n");
	if(roo=='\n')
	{
		str[num]='\0';
		substr = strstr(str, "$GPRMC,");
		if(substr != NULL)
		{
		   for(i=0; i<=strlen(substr); i++)
		   {
			   if(substr[i]==",")
				   j++;
		   }

		}
		num=0;
	}
}


// ****************
int main(void) {
	

	initial_gpio();
	init_uart();
	uint8_t roo = 96;
	NVIC_EnableIRQ(UART2_IRQn);
	printf("started transmission\n");
	while(1)
	{
		//printf("%c", roo);
		if(LPC_UART2->LSR & 0x1)
		{

			roo = LPC_UART2->RBR;
			str[num] = roo;
			num++;
			//printf("There is some data\n");
		}
		if(num == 100)
		{
			str[100]='\0';
			printf("%s", str);
			num = 0;
		}

		//printf("There is no data\n");
		//UART_Receive(LPC_UART2, &roo, 1, BLOCKING);
		//printf("%c", roo);
	}

	return 0 ;
}
